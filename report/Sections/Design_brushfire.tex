\documentclass[../Head/Main.tex]{subfiles}
\begin{document}
\subsection{Model based planer}

The brushfire algorithm uses a grid to approximate distance to obstacles. The idea is to give obstacles a starting value of 1 and free-space pixels a value of 0. Then continue until the $'fire'$ has consumed all free pixels thereby giving pixels furthest away from obstacles the highest value. It was decided to use a eight-point connectivity grid. Pseudo code for the implementation of the brushfire algorithm is giving below.          

\begin{Pseudo}{Brushfire algorithm}{}

	\textbf{while} True \textbf{do}
	

	\begin{Indentation}
	\item \textit{label}++
	\begin{Indentation}

	\item for all \textit{i} hight of image 
	\begin{Indentation}
	\item for all \textit{j} width of image 
	\item if adjacent pixel values to image($i, j $) is \textit{label} $\&$ image($i, j$) is 0 set image($i, j $) to \textit{label} + 1	
	
	\end{Indentation}
	
	\item \textbf{until}
				
	\begin{itemize}
	\item All pixels have an assigned value 
	\end{itemize}

	\end{Indentation}
	
	 \item end \textbf{while}

	\end{Indentation}
	
\end{Pseudo}

The reason for choosing this algorithm is that it gives a set of values to the pixels furthest away from the obstacles, which can be used to generate a path for the robot by picking out the pixels that leads to a complete road map for the robot to navigate through the entire map. 

By using the brushfire algorithm as described above it is possible to get information about certain points of the map with the highest value. Now by looking at the corners and center lines generated by the brushfire algorithm one can get the desired values. The idea here is the use a 4-point connectivity grid where each $pixel(i,j)$ value is compared to its neighbours. For instance if $pixel(i-1,j)$ equals $pixel(i+1,j)$ and the center point between them, $pixel(i,j)$, has a different value, it is considered to be a point on a line. The same thing goes for the horizontal case. To find corner points, the $pixel(i-1,j-1)$ must equal $pixel(i-1,j+1)$ and the point $pixel(i,j)$ must then be different from those two points.

\begin{Pseudo}{Find center points (Horizontal case)}{}

 	\textbf{for} \textit{i} hight of image 
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textbf{for} all \textit{j} width of image 
	\item if $pixel(i-1,j)$ \textbf{\&} pixel$pixel(i+1,j)$ \textbf{\&} $pixel(i+1,j)$ $\neq$ $pixel(i,j)$ 
	\item push vector on list of center points
	\end{Indentation}
	
	
	\end{Indentation}
	
\end{Pseudo}
   
Now one can assign a \textit{weight} to the list of corner and center points so one can differentiate the wanted points from others. After doing this the newly created map will contain the edges and center lines which is interesting for the creation of the path. It was decided to use the center of these found lines to use for the creation of the road map.  

\begin{Pseudo}{Find center of lines (Horizontal case)}{}

 	\textbf{for} \textit{i} hight of image 
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textbf{for} all \textit{j} width of image 
	\item \textbf{while} True \textbf{do}
	\item push $pixel(i,j)$ on vector
	
	\item \textbf{until}
				
	\begin{itemize}
	\item $pixel(i,j) \neq weight$  
	\end{itemize}
	
	\item end \textbf{while} 
	
	\item if size of vector $>$ 2
	\item push $pixel(i,j)$ on list of wanted points
	\end{Indentation}
	
	\end{Indentation}

	
\end{Pseudo} 

Now in the creation of the road map every point is considered to be a vertex and a connection between two vertexes is an edge. Now the interesting part is to find out which vertexes that can be connected to one another without hitting an obstacle. Because all obstacles have been assigned the value of 1 it is possible to iterate through the map and see if $pixel(i,j) == 1$ is located somewhere on the edge between these two vertexes. If that is not the case, the edge is considered valid and saved as an edge and thereby a possible connection between two vertexes.  

\begin{Pseudo}{Connected vertexes}{}

 	\textbf{for} \textit{i} hight of image 
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textbf{for} all \textit{j} width of image 
	\item \textbf{if} \textit{line} between V1 and V2 is not on an obstacle   	
	\item push \textit{edge} on vector

	\end{Indentation}
	
	\end{Indentation}

	
\end{Pseudo} 

\begin{Pseudo}{Remove duplicates}{}

 	\textbf{for} all edges 
 	
 	 \textbf{if} $edge(V1,V2)$ == $edge(V2,V1)$  
 	 	
	 Remove one of them

\end{Pseudo} 
 
Now the edges have to be sorted by distance with shortest distance as the first element on the list. This is done so that Kruskal's algorithm can be used to connect all the edges on the list and make a complete connection between all vertexes. Another benefit of using Kruskal's algorithm is to avoid cycles in the graph and thereby making the implementation of finding a path from an initial position to a target location easier. Kruskal's algorithm uses the \textit{disjoint set union/find} algorithm which is an algorithm used to find relations between vertexes. It starts by initializing a vector by the size of the number of edges and sets them to -1. The \textit{unionSets()} connects two vertexes if there connection will not result in a cycle.  The \textit{find()} method uses recursion to see if the vertexes are joint or disjoint, meaning that they form a cycle if they are connected. Pseudo code for both Kruskal's and union/find algorithm can be seen below.     

\begin{Pseudo}{Kruskal's algorithm}{}

 	\textbf{for} all edges  
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textit{integer} \textbf{\textit{V1}} = find(edge.V1)
	\item \textit{integer} \textbf{\textit{V2}} = find(edge.V2)
	\item \textbf{if} $\textbf{V1} \neq \textbf{V2}$   	
	\item push \textit{edge} on vector
	\item unionSets(\textbf{\textit{V1}},\textbf{\textit{V2}})

	\end{Indentation}
	
	\end{Indentation}

\end{Pseudo} 


\begin{Pseudo}{Find}{}

 \textbf{Input:} A \textit{vertex}
 
 \textbf{Output:} The set containing the \textit{vertex}
 
	\begin{Indentation}
	\item
	
	\item \textbf{if} vector(\textit{vertex}) $ < 0$
 	  \item return \textit{vertex} 
 	\item \textbf{else} 
 	  \item return \textit{find}(vector(\textit{vertex}))
	
	\end{Indentation}

\end{Pseudo} 



\begin{Pseudo}{UnionSet}{}

 \textbf{Input:} V1 and V2
 
 \textbf{Output:} The set containing the \textit{vertex}
 
	\begin{Indentation}
	\item
	
	\item vector(V1) = V2
	
	\end{Indentation}

\end{Pseudo} 

Now the idea of generating connections between all vertexes on the map is complete. The last thing which needs to be solved is to be able to generate a path between vertexes from an initial position to a target location. It must be known which vertexes can be connected to one another. This will give a list of adjacent vertexes to a specific vertex. 
   
\begin{Pseudo}{Adjacent vertexes}{}

 
 	\textbf{for} all \textit{vertexes}
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textbf{for} all \textit{edges}
	\item \textbf{if} \textit{vertex} == edge.\textbf{\textit{V1}}
		\item push edge.\textbf{\textit{V2}} to vector of vectors
	\item \textbf{else if} \textit{vertex} == edge.\textbf{\textit{V2}}
		\item push edge.\textbf{\textit{V1}} to vector of vectors

	\end{Indentation}
	
	\end{Indentation}

\end{Pseudo} 

The final step in getting a path from any of the vertexes to any other vertex is using an extended version of the \textit{Depth-First Search} algorithm. This algorithm uses recursion to find a path between vertexes. It uses the newly found vector of vector (vertexes) to recursely generating a full path from a start vertex to target vertex. 

   
\begin{Pseudo}{DFS extended}{}

\textbf{Input:} Start and target location 

\textbf{Output:} Vector of vertexes in order


	\begin{Indentation}
		\item push \textit{start} on vector 
		\item mark \textit{start} as \textit{visited} 
		\item[ ] 
		\item \textbf{if} $\textit{start}==\textit{target}$
		\item return vector
		\item[ ]
	\item \textbf{for} all vertexes \textit{adjacent} to start
	\item \textbf{if} $\textit{adjacent}==\textit{target}$
		\item push \textit{adjacent} on vector 
		\item return vector
		\item[ ]
	\item \textbf{else if} $\textit{adjacent}\neq\textit{visited}$
	\item DFS(\textit{adjacent},\textit{target})
	\item pop last element from vector 

	\end{Indentation}
	
	
\end{Pseudo} 

Thus the user should be able to give a start and target location from the number of vertexes from the list yielding a complete route for the robot to travel.


\end{document}