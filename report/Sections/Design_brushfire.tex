\documentclass[../Head/Main.tex]{subfiles}
\begin{document}
\subsection{Model based planer}

The brushfire algorithm uses a grid to approximate distance to obstacles. The idea is to give obstacles a starting value of 1 and free-space pixels a value of 0. Then continue until the $'fire'$ has consumed all free pixels thereby giving pixels furthest away from obstacles the highest value. It was decided to use a eight-point connectivity grid. Pseudo code for the implementation of the brushfire algorithm is giving below.          

\begin{Pseudo}{Brushfire algorithm}{}

	\textbf{while} True \textbf{do}
	

	\begin{Indentation}
	\item $label$++
	\begin{Indentation}

	\item for all \textit{i} hight of image 
	\begin{Indentation}
	\item for all \textit{j} width of image 
	\item if adjacent pixel values to image($i, j $) is zero set image($i, j $) to \textit{label} + 1	
	
	\end{Indentation}
	
	\item \textbf{until}
				
	\begin{itemize}
	\item All pixels have an assigned value 
	\end{itemize}

	\end{Indentation}
	
	 \item end \textbf{while}

	\end{Indentation}
	
\end{Pseudo}

The reason for choosing this algorithm is that it gives a set of values to the pixels furthest away from the obstacles, which can be used to generate a path for the robot by picking out the pixels that leads to a complete road map for the robot to navigate through the entire map. 

By using the brushfire algorithm as described above it is possible to get information about certain points of the map with the highest value. Now by looking a the corners and center lines generated by the brushfire algorithm one can get the desired values. The idea here is the use a 4-point connectivity grid where each $pixel(i,j)$ value is compared to its neighbours. For instance if $pixel(i-1,j)$ equals $pixel(i+1,j)$ and the center point between them, $pixel(i,j)$, has a different value, it is considered to be a point on a line. The same thing goes for the horizontal case. To find corners points the$pixel(i-1,j-1)$ must equal $pixel(i-1,j+1)$ and the point $pixel(i,j)$ must then be different from those two points.

\begin{Pseudo}{Find center points(Horizontal case}{}

 	\textbf{for} \textit{i} hight of image 
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textbf{for} all \textit{j} width of image 
	\item if $pixel(i-1,j)$ \textbf{\&} pixel$pixel(i+1,j)$ \textbf{\&} $pixel(i+1,j)$ $\neq$ $pixel(i,j)$ 
	\item push $pixel(i,j)$ on list of center points
	\end{Indentation}
	
	
	\end{Indentation}
	
\end{Pseudo}
   
Now one can assign a \textit{weight} to the list of corner and center points so one can differentiate the wanted points from others. After doing this the newly created map will contain the edges and center lines which is interesting for the creation of the path. It was decided to use the center of these found lines to use for the creation of the road map.  

\begin{Pseudo}{Find center of lines (Horizontal case)}{}

 	\textbf{for} \textit{i} hight of image 
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textbf{for} all \textit{j} width of image 
	\item \textbf{while} True \textbf{do}
	\item push $pixel(i,j)$ on vector
	
	\item \textbf{until}
				
	\begin{itemize}
	\item $pixel(i,j) \neq weight$  
	\end{itemize}
	
	\item end \textbf{while} 
	
	\item if size of vector $>$ 2
	\item push $pixel(i,j)$ on list of wanted points
	\end{Indentation}
	
	\end{Indentation}

	
\end{Pseudo} 

Now in the creation of the road map every point is considered to be a vertex and a connection between two vertexes is an edge. Now the interesting part is to find out which vertexes that can be connected to one another without hitting an obstacle. Because all obstacles have been assigned the value of 1 it is possible to iterate through the map and see if $pixel(i,j) == 1$ is located somewhere on the edge between these two vertexes. If that is not the case, the edge is considered valid and saved as an edge and thereby a possible connection between two vertexes.  

\begin{Pseudo}{Connected vertexes}{}

 	\textbf{for} \textit{i} hight of image 
	\begin{Indentation}
		\item 
	\begin{Indentation}
	\item \textbf{for} all \textit{j} width of image 
	\item \textbf{if} \textit{line} between V1 and V2 is not on an obstacle   	
	\item push \textit{edge} on vector

	\end{Indentation}
	
	\end{Indentation}

	
\end{Pseudo} 

\begin{Pseudo}{Remove duplicates}{}

 	\textbf{for} all edges 
 	
 	 \textbf{if} $edge(V1,V2)$ == $edge(V2,V1)$  
 	 	
	 Remove one of them

\end{Pseudo} 
 
Now the edges have to be sorted by distance with shortest distance as the first element on the list. This is done so that Kruskal's algorithm can be used to connect all the edges on the list and make a complete connection between all vertexes. Another benefit of using Kruskal's algorithm is to avoid cycles in the graph and thereby making the implementation of finding a path from an initial position to a target location easier.      




\end{document}